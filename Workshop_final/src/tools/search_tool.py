"""
Search Tool for E-commerce AI Product Advisor
Implements semantic product search using Pinecone vector database.
"""

import json
from typing import Dict, List, Optional, Any, Type
from pydantic import BaseModel, Field

from langchain.tools import BaseTool
from langchain_core.callbacks import CallbackManagerForToolRun

from src.services.pinecone_service import pinecone_service
from src.utils.logger import get_logger

logger = get_logger("search_tool")


class SearchInput(BaseModel):
    """Input schema for SearchTool"""
    query: str = Field(
        description="Natural language search query in Vietnamese (e.g., 'laptop cho l·∫≠p tr√¨nh', 'ƒëi·ªán tho·∫°i gaming')"
    )
    metadata: Optional[Dict[str, Any]] = Field(
        default_factory=dict,
        description="""Search filters and criteria. Can include:
        - category: 'laptop' or 'smartphone'  
        - subcategory: 'gaming', 'business', 'ultrabook', 'budget', 'flagship', 'mid-range'
        - brand: 'apple', 'samsung', 'dell', 'hp', 'asus', 'lenovo', 'acer', 'msi', 'xiaomi', 'oppo', 'vivo'
        - price_min: minimum price in VND
        - price_max: maximum price in VND
        - max_results: number of results (1-10, default 3)
        - include_reviews: true/false (default false)
        - rating_min: minimum rating (1-5)
        - in_stock: true/false to filter available products
        - os: 'windows', 'macos', 'ubuntu', 'ios', 'android' for OS preference
        - features: list of required features from actual data
        - use_cases: filter by intended usage from actual data
        """
    )


class SearchTool(BaseTool):
    """Tool for searching products using natural language queries"""
    
    name: str = "search_products"
    description: str = """üîç T√åM KI·∫æM s·∫£n ph·∫©m theo ti√™u ch√≠ c·ª• th·ªÉ.
    
    M·ª§C ƒê√çCH: T√¨m s·∫£n ph·∫©m d·ª±a tr√™n c√°c b·ªô l·ªçc v√† ti√™u ch√≠ nh·∫•t ƒë·ªãnh
    
    S·ª¨ D·ª§NG KHI:
    - Kh√°ch h√†ng T√åM s·∫£n ph·∫©m c·ª• th·ªÉ: "t√¨m laptop Dell", "iPhone 15 Pro Max"
    - L·ªçc theo th∆∞∆°ng hi·ªáu: "laptop HP", "smartphone Samsung"  
    - L·ªçc theo gi√°: "laptop d∆∞·ªõi 25 tri·ªáu", "ƒëi·ªán tho·∫°i t·ª´ 10-20 tri·ªáu"
    - L·ªçc theo t√≠nh nƒÉng: "laptop c√≥ SSD", "smartphone camera 48MP"
    - T√¨m theo m·ª•c ƒë√≠ch s·ª≠ d·ª•ng: "laptop gaming", "smartphone ch·ª•p ·∫£nh"
    
    KH√îNG d√πng cho: G·ª£i √Ω ho·∫∑c t∆∞ v·∫•n s·∫£n ph·∫©m ph√π h·ª£p
    
    OUTPUT: Danh s√°ch s·∫£n ph·∫©m kh·ªõp v·ªõi filters, kh√¥ng c√≥ ranking"""
    
    args_schema: Type[BaseModel] = SearchInput
    return_direct: bool = False

    def run(self, tool_input: str, **kwargs) -> str:
        """Override run method to handle JSON string input properly"""
        try:
            # If input is a JSON string, parse it
            if isinstance(tool_input, str) and tool_input.strip().startswith('{'):
                try:
                    parsed_input = json.loads(tool_input)
                    logger.info(f"üîß Parsed JSON tool input: {parsed_input}")
                    return self._run(**parsed_input, **kwargs)
                except json.JSONDecodeError:
                    logger.warning(f"‚ö†Ô∏è Failed to parse JSON input: {tool_input}")
                    # Fall back to treating as query
                    return self._run(query=tool_input, **kwargs)
            else:
                # Regular string input, treat as query
                return self._run(query=tool_input, **kwargs)
        except Exception as e:
            logger.error(f"‚ùå Error in search tool run: {e}")
            return json.dumps({
                "success": False,
                "error": f"L·ªói t√¨m ki·∫øm: {str(e)}",
                "products": []
            }, ensure_ascii=False)
    
    args_schema: Type[BaseModel] = SearchInput
    return_direct: bool = False
    
    def _run(
        self,
        query: str,
        metadata: Optional[Dict[str, Any]] = None,
        run_manager: Optional[CallbackManagerForToolRun] = None,
        **kwargs
    ) -> str:
        """Execute the search tool"""
        try:
            logger.info(f"üîç Searching products with query: '{query}'")
            logger.info(f"üéØ Search metadata: {metadata}")
            
            # Validate inputs - if no query, provide helpful message
            if not query or not query.strip():
                return json.dumps({
                    "success": False,
                    "error": "ƒê·ªÉ t√¨m ki·∫øm s·∫£n ph·∫©m, b·∫°n vui l√≤ng cho t√¥i bi·∫øt:\n- B·∫°n ƒëang t√¨m lo·∫°i s·∫£n ph·∫©m g√¨?\n- C√≥ y√™u c·∫ßu g√¨ ƒë·∫∑c bi·ªát kh√¥ng?",
                    "products": [],
                    "next_action": "H√£y h·ªèi kh√°ch h√†ng mu·ªën t√¨m s·∫£n ph·∫©m g√¨"
                }, ensure_ascii=False)
            
            # Extract metadata parameters
            if metadata is None:
                metadata = {}
            
            category = metadata.get("category")
            brand = metadata.get("brand")
            price_min = metadata.get("price_min")
            price_max = metadata.get("price_max")
            max_results = metadata.get("max_results", 3)
            include_reviews = metadata.get("include_reviews", False)
            rating_min = metadata.get("rating_min")
            features = metadata.get("features", [])
            
            # Limit max_results
            max_results = min(max_results or 3, 10)

            # Prepare filters
            filters = {}
            if category and category.lower() in ["laptop", "smartphone"]:
                filters["category"] = category.lower()
            
            if brand and brand.strip():
                filters["brand"] = brand.lower().strip()
            
            # Add price filters
            if price_min is not None or price_max is not None:
                price_filter = {}
                if price_min is not None:
                    price_filter["$gte"] = price_min
                if price_max is not None:
                    price_filter["$lte"] = price_max
                filters["price"] = price_filter
            
            # Add rating filter
            if rating_min is not None:
                filters["rating"] = {"$gte": rating_min}
            
            # Search products
            try:
                products = pinecone_service.search_products(
                    query=query.strip(),
                    filters=filters,
                    top_k=max_results,
                    include_reviews=include_reviews
                )
            except Exception as e:
                # Handle Pinecone connection errors
                error_msg = str(e).lower()
                if "not found" in error_msg or "404" in error_msg:
                    return json.dumps({
                        "success": False,
                        "error": "C∆° s·ªü d·ªØ li·ªáu s·∫£n ph·∫©m ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p. Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n ƒë·ªÉ kh·ªüi t·∫°o d·ªØ li·ªáu.",
                        "products": [],
                        "setup_required": True
                    })
                else:
                    return json.dumps({
                        "success": False,
                        "error": f"L·ªói k·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu: {str(e)}",
                        "products": []
                    })
            
            # Format results
            if not products:
                return json.dumps({
                    "success": True,
                    "message": "Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ph√π h·ª£p",
                    "products": [],
                    "suggestions": [
                        "Th·ª≠ t√¨m ki·∫øm v·ªõi t·ª´ kh√≥a kh√°c",
                        "M·ªü r·ªông ph·∫°m vi gi√°",
                        "Th·ª≠ danh m·ª•c s·∫£n ph·∫©m kh√°c"
                    ]
                })
            
            # Process products for better display
            processed_products = []
            for product in products:
                processed_product = {
                    "id": product.get("id"),
                    "name": product.get("name"),
                    "brand": product.get("brand"),
                    "category": product.get("category"),
                    "price": product.get("price"),
                    "currency": product.get("currency", "VND"),
                    "rating": product.get("rating", 0),
                    "description": product.get("description", ""),
                    "features": product.get("features", []),
                    "specs": product.get("specs", {}),
                    "similarity_score": round(product.get("similarity_score", 0), 3)
                }
                
                # Add reviews if requested
                if include_reviews and "reviews" in product:
                    processed_product["reviews"] = product["reviews"][:3]  # Limit to 3 reviews
                
                processed_products.append(processed_product)
            
            result = {
                "success": True,
                "message": f"T√¨m th·∫•y {len(processed_products)} s·∫£n ph·∫©m ph√π h·ª£p",
                "query": query,
                "category": category,
                "brand": brand,
                "price_range": {
                    "min": price_min,
                    "max": price_max
                } if price_min is not None or price_max is not None else None,
                "products": processed_products,
                "total_found": len(processed_products),
                "filters_applied": filters
            }
            
            logger.info(f"‚úÖ Search completed: {len(processed_products)} products found")
            return json.dumps(result, ensure_ascii=False, indent=2)
            
        except Exception as e:
            logger.error(f"‚ùå Search tool error: {e}")
            return json.dumps({
                "success": False,
                "error": f"L·ªói t√¨m ki·∫øm: {str(e)}",
                "products": []
            })
    
    async def _arun(
        self,
        query: str,
        metadata: Optional[Dict[str, Any]] = None,
        run_manager: Optional[CallbackManagerForToolRun] = None,
    ) -> str:
        """Async version of the tool"""
        return self._run(query, metadata, run_manager)


# Create tool instance
search_tool = SearchTool()
